OS
DBMS
OOPS

PYTHON3:
take space separated array of ints as input
a = list(map(int,input().split()))

to print on separate lines
print(a,end='\n')
print(a,sep=' ')

to print space separated 
for i in a:
    print(i,end=' ')

C++:
vector<int> v; v.size(); vector<int>::iterator it;  it=v.begin();
int arr[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
(*tail).next = tmp;     //tail ->next = tmp
char arr[100];
cin >> arr;
int len = strlen(arr);

Heaps: TO BE DONE

WITH PRIORITY QUEUE YOU CAN ONLY POP, YOU CANT REMOVE AN ELEMENT FROM ANYWHERE INBETWEEN, for that you need to write your own heap.
they are implemented by priority queue, by default it is a max heap ie max element on top
// C++ program to show that priority_queue is by 
// default a Max Heap 
#include <bits/stdc++.h> 
using namespace std; 
  
// Driver code 
int main () 
{ 
    // Creates a max heap 
    priority_queue <int> pq; 
    pq.push(5); 
    pq.push(1); 
    pq.push(10); 
    pq.push(30); 
    pq.push(20); 
  
    // One by one extract items from max heap 
    while (pq.empty() == false) 
    { 
        cout << pq.top() << " "; 
        pq.pop(); 
    } 
  
    return 0; 
} 

MIN HEAP :
// C++ program to us priority_queue to implement min heap 
#include <bits/stdc++.h> 
using namespace std; 
  
// Driver code 
int main () 
{ 
    // Creates a min heap 
    priority_queue <int, vector<int>, greater<int> > pq; 
    pq.push(5); 
    pq.push(1); 
    pq.push(10); 
    pq.push(30); 
    pq.push(20); 
  
    // One by one extract items from min heap 
    while (pq.empty() == false) 
    { 
        cout << pq.top() << " "; 
        pq.pop(); 
    } 
  
    return 0; 
} 
Run on IDE

Output :

1 5 10 20 30 

--------------------------------  HASHMAP:  ----------------------------------------------------------------------


// C++ program to demonstrate functionality of unordered_map 
#include <iostream> 
#include <unordered_map> 
using namespace std; 
  
int main() 
{ 
    // Declaring umap to be of <string, double> type 
    // key will be of string type and mapped value will 
    // be of double type 
    unordered_map<string, double> umap; 
  
    // inserting values by using [] operator 
    umap["PI"] = 3.14; 
    umap["root2"] = 1.414; 
    umap["root3"] = 1.732; 
    umap["log10"] = 2.302; 
    umap["loge"] = 1.0; 
  
    // inserting value by insert function 
    umap.insert(make_pair("e", 2.718)); 
  
    string key = "PI"; 
  
    // If key not found in map iterator to end is returned
    unordered_map<string,double>::iterator it;
    it = umap.find(key);
    cout<<it->second;	 		 
    if (umap.find(key) == umap.end()) 
        cout << key << " not found\n\n"; 
  
    // If key found then iterator to that key is returned 
    else
        cout << "Found " << key << "\n\n"; 
  
    key = "lambda"; 
    if (umap.find(key) == umap.end()) 
        cout << key << " not found\n"; 
    else
        cout << "Found " << key << endl; 
  
    //    iterating over all value of umap 
    unordered_map<string, double>:: iterator itr; 
    cout << "\nAll Elements : \n"; 
    for (itr = umap.begin(); itr != umap.end(); itr++) 
    { 
        // itr works as a pointer to pair<string, double> 
        // type itr->first stores the key part  and 
        // itr->second stroes the value part 
        cout << itr->first << "  " << itr->second << endl; 
     } 
} 

#include <utility>      // std::pair
#include <iostream>     // std::cout

int main () {
  std::pair <int,int> foo;
  std::pair <int,int> bar;

  foo = std::make_pair (10,20);
  bar = std::make_pair (10.5,'A'); // ok: implicit conversion from pair<double,char>

  std::cout << "foo: " << foo.first << ", " << foo.second << '\n';
  std::cout << "bar: " << bar.first << ", " << bar.second << '\n';

  return 0;
}

Solve it by hand on pen paper and code your technique;

FOLLOW GFG VIDEOS ON YOUTUBE TO SAVE TIME.

------------------------------------- TREES --------------------------------------------------------------

AVL TREES are height balanced trees. ie on insertion we need to left rotate and right rotate to make it balanced see GFG.

Properties of B-Tree
1) All leaves are at same level.
2) A B-Tree is defined by the term minimum degree ‘t’. The value of t depends upon disk block size.
3) Every node except root must contain at least t-1 keys. Root may contain minimum 1 key.
4) All nodes (including root) may contain at most 2t – 1 keys.
5) Number of children of a node is equal to the number of keys in it plus 1.
6) All keys of a node are sorted in increasing order. The child between two keys k1 and k2 contains all keys in the range from k1 and k2.
7) B-Tree grows and shrinks from the root which is unlike Binary Search Tree. Binary Search Trees grow downward and also shrink from downward.
8) Like other balanced Binary Search Trees, time complexity to search, insert and delete is O(Logn).



------------------------------------- GRAPHS --------------------------------------------------------------

Bridges in a graph - https://www.youtube.com/watch?v=thLQYBlz2DM&index=21&list=PLqM7alHXFySEaZgcg7uRYJFBnYMLti-nh

Prim kruskal djikstra Kosaraju - https://www.youtube.com/watch?v=RqQBh_Wbcu4&index=22&list=PLqM7alHXFySEaZgcg7uRYJFBnYMLti-nh

Adjacency list and adjacency mar=trix representation

Applications of Breadth First Traversal
We have earlier discussed Breadth First Traversal Algorithm for Graphs. We have also discussed Applications of Depth First Traversal. In this article, applications of Breadth First Search are discussed.

1) Shortest Path and Minimum Spanning Tree for unweighted graph In an unweighted graph, the shortest path is the path with least number of edges. With Breadth First, we always reach a vertex from given source using the minimum number of edges. Also, in case of unweighted graphs, any spanning tree is Minimum Spanning Tree and we can use either Depth or Breadth first traversal for finding a spanning tree.

2) Peer to Peer Networks. In Peer to Peer Networks like BitTorrent, Breadth First Search is used to find all neighbor nodes.

3) Crawlers in Search Engines: Crawlers build index using Breadth First. The idea is to start from source page and follow all links from source and keep doing same. Depth First Traversal can also be used for crawlers, but the advantage with Breadth First Traversal is, depth or levels of the built tree can be limited.

4) Social Networking Websites: In social networks, we can find people within a given distance ‘k’ from a person using Breadth First Search till ‘k’ levels.

5) GPS Navigation systems: Breadth First Search is used to find all neighboring locations.

6) Broadcasting in Network: In networks, a broadcasted packet follows Breadth First Search to reach all nodes.

7) In Garbage Collection: Breadth First Search is used in copying garbage collection using Cheney’s algorithm. Refer this and for details. Breadth First Search is preferred over Depth First Search because of better locality of reference:

8) Cycle detection in undirected graph: (Do bfs or dfs and keep marking nodes visited in some array, if we visit a visited node, cycle detected, same for bipartitte)
In undirected graphs, either Breadth First Search or Depth First Search can be used to detect cycle. In directed graph, only depth first search can be used.

9) Ford–Fulkerson algorithm In Ford-Fulkerson algorithm, (finding max flow from source to a sink)we can either use Breadth First or Depth First Traversal to find the maximum flow. Breadth First Traversal is preferred as it reduces worst case time complexity to O(VE2).

10) To test if a graph is Bipartite (use two colors to mark nodes visited alternatively)We can either use Breadth First or Depth First Traversal.

11) Path Finding We can either use Breadth First or Depth First Traversal to find if there is a path between two vertices.

12) Finding all nodes within one connected component: We can either use Breadth First or Depth First Traversal to find all nodes reachable from a given node.

Applications of Depth First Search
Depth-first search (DFS) is an algorithm (or technique) for traversing a graph.

Following are the problems that use DFS as a building block.

1) For an unweighted graph, DFS traversal of the graph produces the minimum spanning tree and all pair shortest path tree.

2) Detecting cycle in a graph 
A graph has cycle if and only if we see a back edge during DFS. So we can run DFS for the graph and check for back edges. (See this for details)

3) Path Finding
We can specialize the DFS algorithm to find a path between two given vertices u and z.
i) Call DFS(G, u) with u as the start vertex.
ii) Use a stack S to keep track of the path between the start vertex and the current vertex.
iii) As soon as destination vertex z is encountered, return the path as the
contents of the stack

See this for details.

4) Topological Sorting (in a DAG if there is an edge between v1 and v2 then v1 should be present before v2 in the sorted array)
Implementation: maintain an extra stack, do DFS when no where else to ie leaf is reached add it stack backrtack add it stack, keep adding to stack till 
there is nowhere to go.
Topological Sorting is mainly used for scheduling jobs from the given dependencies among jobs. In computer science, applications of this type arise in instruction scheduling, ordering of formula cell evaluation when recomputing formula values in spreadsheets, logic synthesis, determining the order of compilation tasks to perform in makefiles, data serialization, and resolving symbol dependencies in linkers [2].

5) To test if a graph is bipartite
We can augment either BFS or DFS when we first discover a new vertex, color it opposited its parents, and for each other edge, check it doesn’t link two vertices of the same color. The first vertex in any connected component can be red or black! See this for details.

6) Finding Strongly Connected Components of a graph A directed graph is called strongly connected if there is a path from each vertex in the graph to every other vertex. (See this for DFS based algo for finding Strongly Connected Components)

7) Solving puzzles with only one solution, such as mazes. (DFS can be adapted to find all solutions to a maze by only including nodes on the current path in the visited set.)


